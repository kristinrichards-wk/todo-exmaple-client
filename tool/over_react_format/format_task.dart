// This file is generated by over_react_format.
// Please see the README for more information: https://github.com/Workiva/over_react_format
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:args/args.dart';
import 'package:crypto/crypto.dart';
import 'package:dart_dev/api.dart';
import 'package:dart_dev/dart_dev.dart' show CliResult, Task, TaskCli;
import 'package:dart_dev/util.dart' show TaskProcess, reporter;

Future<Null> main(List<String> arguments) async {
  reporter.color = true;

  var argParser = new ArgParser()
    ..addFlag('help',
        defaultsTo: false,
        negatable: false)
    ..addFlag('check',
        negatable: false,
        help: 'Sets the exit code if files were modified.\n'
              'This is NOT a "dry-run" option, as formatting changes\n'
              'will always be written to disk.')
    ..addOption('line-length',
        abbr: 'l', help: 'Wrap lines longer than this.');

  var parsedArgs = argParser.parse(arguments);
  try {
    parsedArgs = argParser.parse(arguments);
  } on FormatException catch (err) {
    usageError(argParser, err.message);
  }

  if (parsedArgs['help']) {
    printUsage(argParser);
    exit(0);
  }

  var result = await run(parsedArgs);

  if (result.successful) {
    reporter.success(result.message, shout: true);
  } else {
    reporter.error(result.message, shout: true);
    exitCode = 1;
  }
}

Future<CliResult> run(ArgResults parsedArgs) async {
  bool configCheck;
  List<String> configPaths;
  List<String> configExclude;
  int configLineLength;

  reporter.log('Loading `format` config from dart_dev...');
  try {
    var result = Process.runSync('pub', ['run', 'dart_dev', 'export-config']);
    if (result.exitCode != 0) {
      // If something went wrong, check to see if it's due to immediate dependencies not being installed.
      if (!hasPubExecutable('dart_dev')) {
        return new CliResult.fail('Package "dart_dev" must be an immediate dependency in order to run its executables.');
      }

      return new CliResult.fail('Failed to load dart_dev config: ${result.stderr}');
    }

    var ddevConfigJson = JSON.decode(result.stdout);

    Map<String, dynamic> formatConfig = ddevConfigJson['format'];
    configCheck = formatConfig['check'] as bool;
    configPaths = formatConfig['paths'] as List<String>;
    configExclude = formatConfig['exclude'] as List<String>;
    configLineLength = formatConfig['lineLength'] as int;
  } catch (error) {
    return new CliResult.fail('Failed to parse dart_dev config.\n$error');
  }

  List<String> paths = parsedArgs.rest.isNotEmpty ? parsedArgs.rest : configPaths;
  List<String> exclude = configExclude;

  bool check = TaskCli.valueOf('check', parsedArgs, configCheck);
  var lineLength = TaskCli.valueOf('line-length', parsedArgs, configLineLength);
  if (lineLength is String) lineLength = int.parse(lineLength);

  var task = format(
    check: check,
    paths: paths,
    exclude: exclude,
    lineLength: lineLength,
  );

  task.formatterOutput.listen(null, onError: reporter.error);

  await task.done;

  if (!task.successful) {
    // If something went wrong, check to see if it's due to immediate dependencies not being installed.
    if (!hasPubExecutable('dart_style:format')) {
      return new CliResult.fail('Package "dart_style" must be an immediate dependency in order to run its executables.');
    }
    if (!hasPubExecutable('over_react_format')) {
      return new CliResult.fail('Package "over_react_format" must be an immediate dependency in order to run its executables.');
    }
  }


  String excludedFilesWarning = '';
  if (task.excludedFiles.isNotEmpty) {
    excludedFilesWarning = 'WARNING - These files were excluded:\n    ';
    excludedFilesWarning += task.excludedFiles.join('\n    ');
    excludedFilesWarning += '\n\n';
  }

  if (task.check) {
    if (task.successful) {
      return new CliResult.success(excludedFilesWarning + 'Your Dart code is good to go!');
    }

    if (task.affectedFiles.isEmpty) {
      return new CliResult.fail('Dart formatter failed.');
    }

    return new CliResult.fail(excludedFilesWarning +
        'Some files have been formatted; please check in latest changes:\n    ' +
        task.affectedFiles.join('\n    '));
  } else {
    if (!task.successful) {
      return new CliResult.fail('Dart formatter failed.');
    }

    if (task.affectedFiles.isEmpty) {
      return new CliResult.success(excludedFilesWarning +
          'Success! All files are already formatted correctly.');
    }

    return new CliResult.success(excludedFilesWarning +
        'Success! The following files were formatted:\n    ' +
        task.affectedFiles.join('\n    '));
  }
}

CustomFormatTask format({
  bool check,
  List<String> paths,
  List<String> exclude,
  int lineLength,
}) {
  var filesToFormat = getFilesToFormat(paths: paths, exclude: exclude, alwaysExpand: true);

  final List<List<String>> commands = [
    ['pub', 'run', 'over_react_format', 'commas', '-w'],
    ['pub', 'run', 'dart_style:format', '-w', '-l', '$lineLength'],
    ['pub', 'run', 'over_react_format', 'parens', '-w'],
  ];

  var doneCompleter = new Completer();

  var task = new CustomFormatTask(doneCompleter.future)
    ..check = check
    ..files.addAll(filesToFormat.files)
    ..excludedFiles.addAll(filesToFormat.excluded);

  Future runCommandsAsync() async {
    if (filesToFormat.files.isNotEmpty) {
      var hashesBeforeFormat = getHashesForFiles(filesToFormat.files);

      for (var i = 0; i < commands.length; i++) {
        var command = commands[i];

        reporter.log('Step ${i + 1}/${commands.length}: ' + reporter.colorBlue('${command.join(' ')} [files...]'));

        var executable = command.first;
        var args = command.skip(1).toList()..addAll(filesToFormat.files);

        TaskProcess process = new TaskProcess(executable, args);

        process.stdout.listen(task._formatterOutput.add);
        process.stderr.listen(task._formatterOutput.addError);

        // Wait for the command to finish before proceeding to the next one.
        var code = await process.exitCode;
        if (code != 0) {
          task.successful = false;
          return;
        }
      }

      var hashesAfterFormat = getHashesForFiles(filesToFormat.files);

      task.affectedFiles = [];

      for (var file in filesToFormat.files) {
        if (hashesBeforeFormat[file] != hashesAfterFormat[file]) {
          reporter.log('    Formatted $file');
          task.affectedFiles.add(file);
        } else {
          reporter.log('    Unchanged $file');
        }
      }

      if (check && task.affectedFiles.isNotEmpty) {
        task.successful = false;
        return;
      }
    }

    task.successful = true;
  }

  doneCompleter.complete(runCommandsAsync());

  return task;
}

class CustomFormatTask extends Task {
  List<String> files = [];
  List<String> excludedFiles = [];

  List affectedFiles = [];

  double progress;

  @override
  final Future<Null> done;

  bool check;

  StreamController<String> _formatterOutput = new StreamController();

  CustomFormatTask(this.done) {
    done.then((_) => _formatterOutput.close());
  }

  Stream<String> get formatterOutput => _formatterOutput.stream;
}

Map<String, String> getHashesForFiles(Iterable<String> files) {
  return new Map.fromIterables(files, files.map(hashFile));
}

String hashFile(String path) {
  return md5.convert(new File(path).readAsBytesSync()).toString();
}

bool hasPubExecutable(String executable, {List<String> additionalArgs: const ['--help']}) {
  var result = Process.runSync('pub', ['run', executable]..addAll(additionalArgs));
  return result.exitCode == 0;
}

/// Prints [error] and usage help then sets exit code 64.
void usageError(ArgParser parser, String error) {
  printUsage(parser, error);
  exit(64);
}

void printUsage(ArgParser parser, [String error]) {
  var output = reporter.log;

  var message =
      'Custom `dart_dev format` task to improve readability of over_react code\n'
      'formatted with dartfmt, using over_react_format.';

  if (error != null) {
    message = error;
    output = reporter.warning;
  }

  output(message);
  output('''

Usage:

    pub run dart_dev format <flags> [files or directories...]

${parser.usage}

This task is a drop-in replacement for the built-in `dart_dev format` task,
and can similarly be configured by modifying `config.format` in `tool/dev.dart`.

The task performs the following steps:
    1. Runs `over_react_format commas` to improve dartfmt output of nested components.
    2. Runs dartfmt.
    3. Runs `over_react_format parens` command to fix up dartfmt output.
''');
}